import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.LinkedList;
import java.util.Queue;

import DBMS.DBMS;

/**
 * The object used for executing a static SQL statement and returning the
 * results it produces.
 * 
 * By default, only one ResultSet object per Statement object can be open at the
 * same time. Therefore, if the reading of one ResultSet object is interleaved
 * with the reading of another, each must have been generated by different
 * Statement objects. All execution methods in the Statement interface
 * implicitly close a statment's current ResultSet object if an open one exists.
 * 
 * @author OmarYousry
 * 
 */
public class JDBCStatement implements Statement {

	/**
	 * this specifies the time limit after which the query is stopped, measured
	 * in milliseconds, at initialization it will equal 0, which means
	 * unlimited.
	 */
	private int queryTimeout = 0;

	/**
	 * the connection that created this statement
	 */
	private JDBCConnection connection = null;

	/**
	 * A queue to hold the SQL queries in order (FIFO)
	 */
	private Queue<String> sqlBatch = null;

	/**
	 * Holds the result of the last executed SQL query.
	 */
	private JDBCResultSet currentResultSet = null;

	/**
	 * Holds the
	 */
	private int currentUpdateCount = -1;

	/**
	 * Constructor
	 * 
	 */
	public JDBCStatement(DBMS dbms, JDBCConnection c) throws SQLException {
		connection = c;
		sqlBatch = new LinkedList<String>();
	}

	/**
	 * Executes the given SQL statement: This method will return true if the SQL
	 * query was a SELECT, or false if it was an UPDATE, INSERT, or DELETE
	 * statement.
	 * 
	 * If the statement was a SELECT query, you can retrieve the results by
	 * calling the getResultSet() method.
	 * 
	 * If the statement was an UPDATE, INSERT, or DELETE statement, you can
	 * retrieve the affected rows count by calling getUpdateCount()
	 */
	@Override
	public boolean execute(String sql) throws SQLException {
		return false;
	}

	/**
	 * Executes the given SQL query (SELECT statement), which returns a single
	 * ResultSet object.
	 */
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		return null;
	}

	/**
	 * Executes the given SQL statement, which may be an INSERT, UPDATE, or
	 * DELETE statement or an SQL statement that returns nothing.
	 * 
	 * This method returns the number of rows matched by the update statement,
	 * not the number of rows that were modified.
	 */
	@Override
	public int executeUpdate(String sql) throws SQLException {
		return 0;
	}

	/**
	 * Adds the given SQL command to the current list of commands for this
	 * Statement object.
	 */
	@Override
	public void addBatch(String sql) throws SQLException {
		if (sqlBatch == null) {
			sqlBatch = new LinkedList<String>();
		}
		if (sql != null) {
			sqlBatch.add(sql);
		}
	}

	/**
	 * Empties this Statement object's current list of SQL commands.
	 */
	@Override
	public void clearBatch() throws SQLException {
		if (sqlBatch != null) {
			sqlBatch.clear();
		}
	}

	/**
	 * Submits a batch of commands to the database for execution and if all
	 * commands execute successfully, returns an array of update counts.
	 */
	@Override
	public int[] executeBatch() throws SQLException {
		return null;
	}

	/**
	 * Releases this Statement object's database and JDBC resources immediately
	 * instead of waiting for this to happen when it is automatically closed.
	 * 
	 * When a Statement is closed, its current ResultSet, if one exists, is also
	 * closed.
	 */
	@Override
	public void close() throws SQLException {

	}

	/**
	 * Retrieves the Connection object that produced this Statement object.
	 */
	@Override
	public Connection getConnection() throws SQLException {
		return connection;
	}

	/**
	 * Retrieves the number of seconds the driver will wait for a Statement
	 * object to execute.
	 */
	@Override
	public int getQueryTimeout() throws SQLException {
		return (queryTimeout / 1000);
	}

	/**
	 * Sets the number of seconds the driver will wait for a Statement object to
	 * execute to the given number of seconds. By default there is no limit on
	 * the amount of time allowed for a running statement to complete. If the
	 * limit is exceeded, an SQLTimeoutException is thrown. A JDBC driver must
	 * apply this limit to the execute, executeQuery and executeUpdate methods.
	 * 
	 * Note: In the case of Statement batching, This implementation applies the
	 * time-out to individual SQL statements, and not the entire batch.
	 */
	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		queryTimeout = 1000 * seconds;
	}

	// --------------------------------------------------------------------\\
	// /////////--------- EXTRA BUT NECESSARY 2 METHODS ----------\\\\\\\\\ \\
	// ----------------------------------------------------------------------\\

	/**
	 * Retrieves the current result as a ResultSet object.
	 */
	@Override
	public ResultSet getResultSet() throws SQLException {
		return currentResultSet;
	}

	/**
	 * Retrieves the current result as an update count; if the result is a
	 * ResultSet object or there are no more results, -1 is returned.
	 */
	@Override
	public int getUpdateCount() throws SQLException {
		return currentUpdateCount;
	}

	// ------------------------------------------------------\\
	// /////////--------- UNUSED METHODS ----------\\\\\\\\\\ \\
	// --------------------------------------------------------\\

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	@Override
	public void cancel() throws SQLException {
	}

	@Override
	public void clearWarnings() throws SQLException {
	}

	@Override
	public void closeOnCompletion() throws SQLException {
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		return false;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		return 0;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return 0;
	}

	@Override
	public int getFetchSize() throws SQLException {
		return 0;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return null;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public int getMaxRows() throws SQLException {
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return false;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return 0;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return false;
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void setCursorName(String name) throws SQLException {
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
	}

}
