import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import java.util.LinkedList;
import java.util.Queue;

import DBMS.*;

import DBMS.DBMS;

import DBMS.DBMS;

/**
 * The object used for executing a static SQL statement and returning the
 * results it produces.
 * 
 * By default, only one ResultSet object per Statement object can be open at the
 * same time. Therefore, if the reading of one ResultSet object is interleaved
 * with the reading of another, each must have been generated by different
 * Statement objects. All execution methods in the Statement interface
 * implicitly close a statment's current ResultSet object if an open one exists.
 * 
 * @author OmarYousry
 * 
 */
public class JDBCStatement implements Statement {

	private static String intPat = "(-){0,1}[0-9]+";
	private static String RealPat = "(-){0,1}[0-9]+(\\.){0,1}[0-9]+";
	private static String stringPat = ".*";
	private static String datePat = "[1-2]([0-9]){3}-((0[1-9])|1[0-2])-([0-2][1-9]|3[0-1])T([0-2][0-3])\\:([0-5][0-9])\\:([0-5][0-9])";
	private static String booleanPat = "(((?i)true)|((?i)false))";

	private static String operatorPat = "(\\*|\\<\\=|\\>\\=|\\=|\\<|\\>)";

	private static String nameReq = "([A-Za-z][A-Za-z0-9]*)";

	private static String selectSpecificPat = "((?i)select)\\s\\(\\s" + "("
			+ nameReq + "\\s\\,\\s" + ")*" + nameReq
			+ "{1}\\s\\)\\s((?i)from)\\s" + nameReq;

	private static String selectAllPat = "((?i)select)\\s"
			+ "\\*\\s((?i)from)\\s" + nameReq;

	private static String deletePat = "((?i)delete)\\s((?i)from)\\s" + nameReq;

	private static String colValPat = "(" + nameReq + "\\s\\=\\s" + stringPat
			+ ")";

	private static String updatePat = "((?i)update)\\s" + nameReq
			+ "\\s((?i)set)\\s" + "(" + colValPat + "\\s\\,\\s" + ")*"
			+ colValPat + "{1}";

	/**
	 * this specifies the time limit after which the query is stopped, measured
	 * in milliseconds, at initialization it will equal 0, which means
	 * unlimited.
	 */
	private int queryTimeout = 0;

	/**
	 * the connection that created this statement
	 */
	private JDBCConnection connection = null;

	/**
	 * A queue to hold the SQL queries in order (FIFO)
	 */
	private Queue<String> sqlBatch = null;

	/**
	 * Holds the result of the last executed SQL query.
	 */
	private ResultSet currentResultSet = null;

	/**
	 * Holds the
	 */
	private int currentUpdateCount = -1;

	/**
	 * A DBMS delegate to execute the actual SQL commands
	 */
	private DBMS dbms;

	/**
	 * Constructor
	 * 
	 */

	public JDBCStatement(DBMS dbms, JDBCConnection c) throws SQLException {
		if (dbms == null || c == null)
			throw new SQLException("Error : Wrong Statement initialization");

		connection = c;
		this.dbms = dbms;
		sqlBatch = new LinkedList<String>();
	}

	/**
	 * Executes the given SQL statement: This method will return true if the SQL
	 * query was a SELECT, or false if it was anUPDATE, INSERT, DELETE, USE or
	 * CRETAE statement.
	 * 
	 * If the statement was a SELECT query, you can retrieve the results by
	 * calling the getResultSet() method.
	 * 
	 * If the statement was an UPDATE, INSERT, DELETE, USE or CRETAE statement,
	 * you can retrieve the affected rows count by calling getUpdateCount()
	 */
	@Override
	public boolean execute(String sql) throws SQLException {
		try {
			executeUpdate(sql);
			return false;
		} catch (SQLException executeUpdateExc) {
			try {
				executeQuery(sql);
				return true;
			} catch (SQLException executeQueryExc) {
				canNotExecuteState();
				throw new SQLException("ERROR : UNDEFINED STATEMENT");
			}
		}
	}

	private void handleConditionedCommand(String sql) {
		sql += " ";
		String[] sqlSplitted = sql.split("\\s((?i)where)\\s");

		if (sqlSplitted.length == 2) {
			// THERE IS A COMMAND, AND A CONDITION

			String command = sqlSplitted[0].trim();
			String condition = sqlSplitted[1].trim();

			if (command.matches(selectSpecificPat)) {
				handleSelectCommand(sqlSplitted);
			} else if (command.matches(updatePat)) {
				handleUpdateCommand(sqlSplitted);
			} else if (command.matches(deletePat)) {
				handelDeleteCommand(sqlSplitted);
			} else {

			}
		} else if (sqlSplitted.length == 1) {
			// NO CONDITION WAS FOUND

			String[] sqlSplitted2 = sql.split(" ");
			String isWhere = sqlSplitted2[sqlSplitted2.length - 1];

			if (isWhere.equalsIgnoreCase("where")) {
				// ERROR : NO CONDITION AFTER WHERE
			} else {
				// UNCONDITIONED STATEMENT
			}
		} else {
			// ERROR
		}
	}

	private void handleSelectCommand(String[] sqlSplitted) {
		// TODO Auto-generated method stub

	}

	private void handleUpdateCommand(String[] sqlSplitted) {
		// TODO Auto-generated method stub

	}

	private void handelDeleteCommand(String[] sqlSplitted) {
		// TODO Auto-generated method stub

	}

	/**
	 * Executes the given SQL query (SELECT statement), which returns a single
	 * ResultSet object.
	 */
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		try {

			sql = prepareSQLStatement(sql);

			if (sql.matches(selectAllPat)) {
				String[] sqlSplitted = sql.split("\\s((?i)from)\\s");

				String tableName = sqlSplitted[1];

				dbms.getUsedDB().getTable(tableName);

				return null;
			} else {
				handleConditionedCommand(sql);
			}
			return null;
		} catch (Exception e) {
			throw new SQLException("ERROR : INVALID SQL STATEMENT");
		}
	}

	/**
	 * Executes the given SQL statement, which may be an INSERT, UPDATE, or
	 * DELETE statement or an SQL statement that returns nothing.
	 * 
	 * This method returns the number of rows matched by the update statement,
	 * not the number of rows that were modified.
	 */
	@Override
	public int executeUpdate(String sql) throws SQLException {

		try {
			sql = prepareSQLStatement(sql);
		} catch (Exception e) {
			throw new SQLException("ERROR : INVALID SQL STATEMENT");
		}

		currentResultSet.close();
		currentResultSet = null;
		return 0;
	}

	/**
	 * Adds the given SQL command to the current list of commands for this
	 * Statement object.
	 */
	@Override
	public void addBatch(String sql) throws SQLException {
		if (sqlBatch == null) {
			sqlBatch = new LinkedList<String>();
		}
		if (sql != null) {
			sqlBatch.add(sql);
		}
	}

	/**
	 * Empties this Statement object's current list of SQL commands.
	 */
	@Override
	public void clearBatch() throws SQLException {
		if (sqlBatch != null) {
			sqlBatch.clear();
		}
	}

	/**
	 * Submits a batch of commands to the database for execution and if all
	 * commands execute successfully, returns an array of update counts.
	 */
	@Override
	public int[] executeBatch() throws SQLException {
		return null;
	}

	/**
	 * Releases this Statement object's database and JDBC resources immediately
	 * instead of waiting for this to happen when it is automatically closed.
	 * 
	 * When a Statement is closed, its current ResultSet, if one exists, is also
	 * closed.
	 */
	@Override
	public void close() throws SQLException {

	}

	/**
	 * Retrieves the Connection object that produced this Statement object.
	 */
	@Override
	public Connection getConnection() throws SQLException {
		return connection;
	}

	/**
	 * Retrieves the number of seconds the driver will wait for a Statement
	 * object to execute.
	 */
	@Override
	public int getQueryTimeout() throws SQLException {
		return (queryTimeout / 1000);
	}

	/**
	 * Sets the number of seconds the driver will wait for a Statement object to
	 * execute to the given number of seconds. By default there is no limit on
	 * the amount of time allowed for a running statement to complete. If the
	 * limit is exceeded, an SQLTimeoutException is thrown. A JDBC driver must
	 * apply this limit to the execute, executeQuery and executeUpdate methods.
	 * 
	 * Note: In the case of Statement batching, This implementation applies the
	 * time-out to individual SQL statements, and not the entire batch.
	 */
	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		queryTimeout = 1000 * seconds;
	}

	// --------------------------------------------------------------------\\
	// /////////--------- EXTRA BUT NECESSARY 2 METHODS ----------\\\\\\\\\ \\
	// ----------------------------------------------------------------------\\

	/**
	 * Retrieves the current result as a ResultSet object.
	 */
	@Override
	public ResultSet getResultSet() throws SQLException {
		return currentResultSet;
	}

	/**
	 * Retrieves the current result as an update count; if the result is a
	 * ResultSet object or there are no more results, -1 is returned.
	 */
	@Override
	public int getUpdateCount() throws SQLException {
		return currentUpdateCount;
	}

	private void canNotExecuteState() throws SQLException {
		currentUpdateCount = -1;
		if (currentResultSet != null) {
			currentResultSet.close();
			currentResultSet = null;
		}
	}

	private static String prepareSQLStatement(String sql) throws Exception {

		if (sql == null) {
			throw new Exception("NULL SQL STRING");
		}

		sql = sql.trim();

		if (sql.equals("")) {
			throw new Exception("EMPTY SQL STRING");
		}

		sql = sql.replaceAll("\\*", " * ");
		sql = sql.replaceAll("\\(", " ( ");
		sql = sql.replaceAll("\\)", " ) ");
		sql = sql.replaceAll("\\,", " , ");
		sql = sql.replaceAll("\\=", " = ");

		while (sql.contains("  "))
			sql = sql.replaceAll("\\s{2}", " ");

		return sql;
	}

	private ResultSet newCurrentResultSet(RecordSet record) throws SQLException {
		if (currentResultSet != null) {
			currentResultSet.close();
		}
		currentUpdateCount = -1;
		currentResultSet = new JDBCResultSet(record, this);
		return currentResultSet;
	}

	public static void main(String[] args) {
		String ss = null;
		try {
			ss = prepareSQLStatement("update friends set age = 10,name=omar, vovo = lklkl , lklhwt = 90");
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println(ss);
		System.out.println(ss.matches(updatePat));
	}

	// ------------------------------------------------------\\
	// /////////--------- UNUSED METHODS ----------\\\\\\\\\\ \\
	// --------------------------------------------------------\\

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	@Override
	public void cancel() throws SQLException {
	}

	@Override
	public void clearWarnings() throws SQLException {
	}

	@Override
	public void closeOnCompletion() throws SQLException {
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		return false;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		return 0;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return 0;
	}

	@Override
	public int getFetchSize() throws SQLException {
		return 0;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return null;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public int getMaxRows() throws SQLException {
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return false;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return 0;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return false;
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void setCursorName(String name) throws SQLException {
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
	}

}
