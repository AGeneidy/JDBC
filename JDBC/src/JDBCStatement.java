import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

import DBMS.*;

/**
 * The object used for executing a static SQL statement and returning the
 * results it produces.
 * 
 * By default, only one ResultSet object per Statement object can be open at the
 * same time. Therefore, if the reading of one ResultSet object is interleaved
 * with the reading of another, each must have been generated by different
 * Statement objects. All execution methods in the Statement interface
 * implicitly close a statment's current ResultSet object if an open one exists.
 * 
 * @author OmarYousry
 * 
 */
public class JDBCStatement implements Statement {

	
	// Remember the problem of reserved words (set , from , where )
	
	private static String stringPat = "(.*)";

	private static String nameReq = "([A-Za-z][A-Za-z0-9]*)";

	private static String selectSpecificPat = "((?i)select)\\s\\(\\s" + "("
			+ nameReq + "\\s\\,\\s" + ")*" + nameReq
			+ "{1}\\s\\)\\s((?i)from)\\s" + nameReq;

	private static String selectAllPat = "((?i)select)\\s"
			+ "\\*\\s((?i)from)\\s" + nameReq;

	private static String deletePat = "((?i)delete)\\s((?i)from)\\s" + nameReq;

	private static String colValPat = nameReq + "\\s\\=\\s" + stringPat;

	private static String updatePat = "((?i)update)\\s" + nameReq
			+ "\\s((?i)set)\\s" + "(" + colValPat + "\\s\\,\\s" + ")*"
			+ colValPat + "{1}";

	private static String usePat = "((?i)use)\\s" + nameReq;

	private static String createDatabasePat = "((?i)create)\\s((?i)database)\\s"
			+ nameReq;

	private static String column_Name_Type = nameReq + "\\s" + stringPat;

	private static String createTablePat = "((?i)create)\\s((?i)table)\\s"
			+ nameReq + "\\s\\(\\s" + "(" + column_Name_Type + "\\s,\\s" + ")*"
			+ column_Name_Type + "{1}\\s\\)";

	private static String insertIntoPat = "((?i)insert)\\s((?i)into)\\s"
			+ nameReq + "\\s\\(\\s" + "(" + nameReq + "\\s\\,\\s" + ")*"
			+ nameReq + "{1}\\s\\)\\s((?i)values)\\s\\(\\s" + "(" + stringPat
			+ "," + ")*" + stringPat + "{1}\\s\\)";

	/**
	 * this specifies the time limit after which the query is stopped, measured
	 * in milliseconds, at initialization it will equal 0, which means
	 * unlimited.
	 */
	private int queryTimeout = 0;

	/**
	 * the connection that created this statement
	 */
	private JDBCConnection connection = null;

	/**
	 * A queue to hold the SQL queries in order (FIFO)
	 */
	private Queue<String> sqlBatch = null;

	/**
	 * Holds the result of the last executed SQL query.
	 */
	private ResultSet currentResultSet = null;

	/**
	 * Holds the
	 */
	private int currentUpdateCount = -1;

	/**
	 * A DBMS delegate to execute the actual SQL commands
	 */
	private DBMS dbms;

	/**
	 * Constructor
	 * 
	 */

	public JDBCStatement(DBMS dbms, JDBCConnection c) throws SQLException {
//		if (dbms == null || c == null)
//			throw new SQLException("Error : Wrong Statement initialization");

		connection = c;
		this.dbms = dbms;
		sqlBatch = new LinkedList<String>();
	}

	/**
	 * Executes the given SQL statement: This method will return true if the SQL
	 * query was a SELECT, or false if it was anUPDATE, INSERT, DELETE, USE or
	 * CRETAE statement.
	 * 
	 * If the statement was a SELECT query, you can retrieve the results by
	 * calling the getResultSet() method.
	 * 
	 * If the statement was an UPDATE, INSERT, DELETE, USE or CRETAE statement,
	 * you can retrieve the affected rows count by calling getUpdateCount()
	 */
	@Override
	public boolean execute(String sql) throws SQLException {
		try {
			executeUpdate(sql);
			return false;
		} catch (SQLException executeUpdateExc) {
			try {
				executeQuery(sql);
				return true;
			} catch (SQLException executeQueryExc) {
				canNotExecuteState();
				throw new SQLException("ERROR : UNDEFINED STATEMENT");
			}
		}
	}

	/**
	 * Executes the given SQL query (SELECT statement), which returns a single
	 * ResultSet object.
	 */
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		try {
			currentUpdateCount = -1;
			sql = prepareSQLStatement(sql);
			
			try{
				handleSelectComm(sql);
			}catch (Exception e){
				e.printStackTrace();
			}
			
			return currentResultSet;
		} catch (SQLException e) {
			throw new SQLException("ERROR : INVALID SQL STATEMENT");
		} catch (NullPointerException e) {
			throw new SQLException(
					"ERROR : EITHER THE TABLE OR THE DATABASE DON'T EXIST");
		}
	}

	/**
	 * Executes the given SQL statement, which may be an INSERT, UPDATE, or
	 * DELETE statement or an SQL statement that returns nothing.
	 * 
	 * This method returns the number of rows matched by the update statement,
	 * not the number of rows that were modified.
	 */
	@Override
	public int executeUpdate(String sql) throws SQLException {
		try {
			if (currentResultSet != null) {
				currentResultSet.close();
				currentResultSet = null;
			}

			sql = prepareSQLStatement(sql);

			if (sql.matches(usePat)) {
				callUse(sql);
			} else if (sql.matches(createDatabasePat)) {
				callCreateDB(sql);
			} else if (sql.matches(createTablePat)) {
				callCreateTable(sql);
			} else {
				handleGeneralCommand(sql);
			}
			return currentUpdateCount;
		} catch (SQLException e) {
			throw new SQLException("ERROR : INVALID SQL STATEMENT");
		} catch (NullPointerException e) {
			throw new SQLException(
					"ERROR : EITHER THE TABLE OR THE DATABASE DON'T EXIST");
		} catch (Exception e) {
			throw new SQLException("ERROR : DBMS ERROR");
		}
	}

	private void callCreateDB(String sql) throws Exception {
		System.out.println("CREATE DB CALLED");
		
		currentUpdateCount = -1;
		String DBName = sql.split(" ")[2];
		dbms.createDB(DBName);
	}

	private void callUse(String sql) throws Exception {
		System.out.println("USE CALLED");
		
		currentUpdateCount = -1;
		String DBName = sql.split(" ")[1];
		dbms.setUsedDB(DBName);
	}

	private void callCreateTable(String sql) throws Exception {
		System.out.println("CREATE TALE CALLED");
		currentUpdateCount = -1;
		String tbName = sql.split(" ")[2];

		String[] cols_names_types = extractColumnsNames(sql);
		ColumnIdentifier[] colsID = new ColumnIdentifier[cols_names_types.length];

		for (int i = 0; i < cols_names_types.length; i++) {
			String[] bySpace = cols_names_types[i].split(" ");
			colsID[i] = new ColumnIdentifier(bySpace);
		}
		dbms.getUsedDB().addTable(tbName, colsID);
	}

	/**
	 * Adds the given SQL command to the current list of commands for this
	 * Statement object.
	 */
	@Override
	public void addBatch(String sql) throws SQLException {
		if (sqlBatch == null) {
			sqlBatch = new LinkedList<String>();
		}
		if (sql != null) {
			sqlBatch.add(sql);
		}
	}

	/**
	 * Empties this Statement object's current list of SQL commands.
	 */
	@Override
	public void clearBatch() throws SQLException {
		if (sqlBatch != null) {
			sqlBatch.clear();
		}
	}

	/**
	 * Submits a batch of commands to the database for execution and if all
	 * commands execute successfully, returns an array of update counts.
	 */
	@Override
	public int[] executeBatch() throws SQLException {
		return null;
	}

	/**
	 * Releases this Statement object's database and JDBC resources immediately
	 * instead of waiting for this to happen when it is automatically closed.
	 * 
	 * When a Statement is closed, its current ResultSet, if one exists, is also
	 * closed.
	 */
	@Override
	public void close() throws SQLException {

	}

	/**
	 * Retrieves the Connection object that produced this Statement object.
	 */
	@Override
	public Connection getConnection() throws SQLException {
		return connection;
	}

	/**
	 * Retrieves the number of seconds the driver will wait for a Statement
	 * object to execute.
	 */
	@Override
	public int getQueryTimeout() throws SQLException {
		return (queryTimeout / 1000);
	}

	/**
	 * Sets the number of seconds the driver will wait for a Statement object to
	 * execute to the given number of seconds. By default there is no limit on
	 * the amount of time allowed for a running statement to complete. If the
	 * limit is exceeded, an SQLTimeoutException is thrown. A JDBC driver must
	 * apply this limit to the execute, executeQuery and executeUpdate methods.
	 * 
	 * Note: In the case of Statement batching, This implementation applies the
	 * time-out to individual SQL statements, and not the entire batch.
	 */
	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		queryTimeout = 1000 * seconds;
	}

	// --------------------------------------------------------------------\\
	// /////////--------- EXTRA BUT NECESSARY 2 METHODS ----------\\\\\\\\\ \\
	// ----------------------------------------------------------------------\\

	/**
	 * Retrieves the current result as a ResultSet object.
	 */
	@Override
	public ResultSet getResultSet() throws SQLException {
		return currentResultSet;
	}

	/**
	 * Retrieves the current result as an update count; if the result is a
	 * ResultSet object or there are no more results, -1 is returned.
	 */
	@Override
	public int getUpdateCount() throws SQLException {
		return currentUpdateCount;
	}

	private void canNotExecuteState() throws SQLException {
		currentUpdateCount = -1;
		if (currentResultSet != null) {
			currentResultSet.close();
			currentResultSet = null;
		}
	}

	private static String prepareSQLStatement(String sql) throws SQLException {

		if (sql == null || (sql = sql.trim()).equals("")) {
			// canNotExecuteState();
			throw new SQLException();
		}
		sql = sql.replaceAll("\\*", " * ");
		sql = sql.replaceAll("\\(", " ( ");
		sql = sql.replaceAll("\\)", " ) ");
		sql = sql.replaceAll("\\,", " , ");
		sql = sql.replaceAll("\\=", " = ");

		while (sql.contains("  "))
			sql = sql.replaceAll("  ", " ");

		return sql.trim();
	}

	private void handleSelectComm(String sql) throws SQLException {
		String[] sqlSplitted = sql.split("\\s((?i)where)\\s");

		boolean firstCaseValid = sqlSplitted.length == 2
				&& sqlSplitted[0].matches(selectSpecificPat);
		
		boolean secondCaseValid = sqlSplitted.length == 1
				&& (sql.matches(selectSpecificPat) || sql.matches(selectAllPat));

		boolean isValidSelect = firstCaseValid || secondCaseValid;

		
		if (isValidSelect) {
			try {
				callSelect(sqlSplitted);
			} catch (NullPointerException e) {
				currentResultSet = null;
				throw new SQLException();
			}
		} else {
			currentResultSet = null;
			throw new SQLException();
		}
	}

	// to be called after regex validation
	private void callSelect(String[] sqlSplitted) throws NullPointerException {
		
		System.out.println("SELECT CALLED");
		
		String[] fromSplitted = sqlSplitted[0].split("\\s((?i)from)\\s");
		String tableName = fromSplitted[1];

		
		// may through NullPointerException, handled
		Table tb = dbms.getUsedDB().getTable(tableName);

		if (tb == null) {
			currentResultSet = null;
			throw new NullPointerException();
		}
		
		String[] colmsNames = tb.getColNames();
		Condition c = null;
		
		

		if (sqlSplitted.length == 2) {
			c = new Condition(sqlSplitted[1], tb);
			colmsNames = extractColumnsNames(sqlSplitted[0]);
		}
		currentResultSet = new JDBCResultSet(tb.select(colmsNames, c), this);
	}

	// to be called after regex validation
	private String[] extractColumnsNames(String string) {
		int indexOfOpenPar = string.indexOf('(');
		int indexOfClosedPar = string.indexOf(')');
		String toBeSplitted = string.substring(indexOfOpenPar + 1,
				indexOfClosedPar);
		return toBeSplitted.trim().split(" , ");
	}

	private void handleGeneralCommand(String sql) throws SQLException {
		String[] sqlSplitted = sql.split("\\s((?i)where)\\s");
		boolean[] hasConditionCase = evaluateMatched(sqlSplitted[0]);
		boolean[] hasNoConditionCase = evaluateMatched(sql);
		boolean firstCaseValid = evaluateOR(hasConditionCase) && sqlSplitted.length == 2;
		boolean secondCaseValid = evaluateOR(hasNoConditionCase) && sqlSplitted.length == 1;
		boolean isValidStmnt = firstCaseValid || secondCaseValid;
		if (isValidStmnt) {
			try {
				if (hasConditionCase[0] == true || hasNoConditionCase[0] == true) {
					callUpdate(sqlSplitted);
				} else if (hasConditionCase[1] == true || hasNoConditionCase[1] == true) {
					callDelete(sqlSplitted);
				} else if (hasConditionCase[2] == true || hasNoConditionCase[2] == true) {
					callInsert(sqlSplitted);
				} else {
					currentUpdateCount = -1;
					throw new SQLException();
				}
			} catch (Exception e) {
				currentUpdateCount = -1;
				throw new SQLException();
			}
		} else {
			currentUpdateCount = -1;
			throw new SQLException();
		}
	}

	private void callInsert(String[] sqlSplitted) throws Exception {
		
		System.out.println("INSERT CALLED");
		
		currentUpdateCount = -1;
		
		String tbName = sqlSplitted[0].split(" ")[2];
		Table tb = dbms.getUsedDB().getTable(tbName);
		
		if (tb == null){
			throw new NullPointerException();
		}
		String[] colsNames = extractColumnsNames(sqlSplitted[0]);
		
		String[]tempArr =  sqlSplitted[0].split("\\s((?i)values)\\s");
		String[] values = extractColumnsNames(tempArr[1]);
	
		tb.insert(new Record(colsNames, values, tb));
	}

	private void callDelete(String[] sqlSplitted) throws Exception {
		System.out.println("DELETE CALLED");
		
		String tbName = sqlSplitted[0].split(" ")[2];
		Table tb = dbms.getUsedDB().getTable(tbName);
		
		if (tb == null){
			currentUpdateCount = -1;
			throw new NullPointerException();
		}
		
		Condition c = null;
		if (sqlSplitted.length == 2)
			c = new Condition(sqlSplitted[1], tb);
		
		tb.delete(c);
	}

	private void callUpdate(String[] sqlSplitted) throws Exception{
		System.out.println("UPDATE CALLED");
		
		String[] setSplitted = sqlSplitted[0].split("\\s((?i)set)\\s");
		String[] afterSet = setSplitted[1].split(" , ");
		
		String[] columnsNames = new String[afterSet.length];
		String[] values = new String[afterSet.length];
		
		for (int i = 0; i < afterSet.length; i++) {
			String[] splittedVals = afterSet[i].split(" = ");
			columnsNames[i] = splittedVals[0];
			values[i] = splittedVals[1];
		}
		String tbName = sqlSplitted[0].split(" ")[1];
		Table tb = dbms.getUsedDB().getTable(tbName);
		
		if (tb == null){
			currentUpdateCount = -1;
			throw new NullPointerException();
		}
		Condition c = null;
		if (sqlSplitted.length == 2)
			c = new Condition(sqlSplitted[1], tb);
		
		currentUpdateCount = tb.update(columnsNames, values, c);
	}

	private boolean evaluateOR(boolean[] arr) {
		int i = 0;
		boolean val = false;
		while (i < arr.length)
			val |= arr[i++];
		return val;
	}

	private boolean[] evaluateMatched(String str) {
		boolean[] toRet = new boolean[3];
		Arrays.fill(toRet, false);

		if (str.matches(updatePat)) {
			toRet[0] = true;
			return toRet;
		} else if (str.matches(deletePat)) {
			toRet[1] = true;
			return toRet;
		} else if (str.matches(insertIntoPat)) {
			toRet[2] = true;
			return toRet;
		} else {
			return toRet;
		}
	}

	public static void main(String[] args) {
		
		String ss1 = "create database newDB" ;
		String ss2 = "use newDB" ;
		String ss3 = "create table newTb (c1 Integer , c2 Varchar , c3 boolean)" ;
		String ss4 = "insert into newTb (c1 , c2 , c3) values (10 , 'omar' , true)" ;
		String ss5 = "insert into newTb (c1 , c3 ) values (20 , true)" ;
		String ss6 = "insert into newTb (c3 , c2 ) values (false , 'boody')" ;
		String ss7 = "insert into newTb (c3 , c3 ) values (false , true)" ;
		String ss8 = "insert into newTb (c2 , c3 ) values ('mariam' , true)" ;
		String ss9 = "select* from newTb " ;
		
		String ss10 = "select from newTb " ;
		
		String ss11 = "select (c1, c2) from newTb where c3 = true" ;
		String ss12 = "delete from newTb where c3 = true" ;
		Statement s = null;
		
		try {
			 s = new JDBCStatement(new StdDBMS(), null);
			 s.execute(ss1);
			 s.execute(ss2);
			 s.execute(ss3);
			 s.execute(ss4);
			 s.execute(ss5);
			 s.execute(ss6);
			 s.execute(ss7);
			 s.execute(ss8);
			 s.execute(ss9); 
			
			 // s.execute(ss10);

			 s.execute(ss11);
			 s.execute(ss12);
		} catch (Exception e) {
			System.out.println("LOL!");
			e.printStackTrace();
		}
		
	}

	// ------------------------------------------------------\\
	// /////////--------- UNUSED METHODS ----------\\\\\\\\\\ \\
	// --------------------------------------------------------\\

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	@Override
	public void cancel() throws SQLException {
	}

	@Override
	public void clearWarnings() throws SQLException {
	}

	@Override
	public void closeOnCompletion() throws SQLException {
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		return false;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		return 0;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return 0;
	}

	@Override
	public int getFetchSize() throws SQLException {
		return 0;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return null;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public int getMaxRows() throws SQLException {
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return false;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return 0;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return false;
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void setCursorName(String name) throws SQLException {
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
	}

}
